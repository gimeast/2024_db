# JDBC 이해
```
JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API다.
JDBC는 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
```

JDBC -> 인터페이스  
Mysql 드라이버, Oracle 드라이버 -> 구현체(구현 라이브러리)

표준화의 한계
데이터베이스를 변경하면 JDBC 코드는 변경하지 않아도 되지만 SQL은 해당 데이터베이스에 맞도록 변경해야한다. 
참고로 JPA를 사용하면 이 문제를 대부분 해결할 수 있다.

## JDBC와 최신 데이터 접근 기술
```
JDBC를 직접 사용하는것은 애플리케이션 단에서 JDBC를 통해서 SQL을 직접 전달하면 된다.
이 방법은 사용법이 복잡하다.
```
JDBC를 편리하게 사용하는 다양한 기술이 있다.

1. SqlMapper
   1. 대표적 기술
      - 스프링 JDBC Template
      - MyBatis
   2. 장점
      - 응답결과를 객체로 편리하게 변환해준다.
      - JDBC의 반복 코드를 제거할 수 있다.
   3. 단점
      - 개발자가 SQL을 직접 작성해야한다. (ORM과 비교할 경우의 단점이다.)
2. ORM
    - ORM은 객체를 관계형 데이터 베이스 테이블과 매핑 해주는 기술이다.
    - 직접 SQL을 작성하지않고 컬렉션에 객체를 넣는것 처럼 JPA에 넣어주면 ORM 기술이 개발자 대신 SQL을 동적으로 만들어 실행해준다.
    - 대표기술: JPA(인터페이스), 하이버네이트(구현체), 이클립스링크(구현체)

```
이런 기술들도 내부에서는 모두 JDBC를 사용한다.
따라서 JDBC를 직접 사용하지는 않더라도 기본원리를 알아야 해당 기술들을 더 깊이 이해할수 있고
문제가 발생한경우 근본적 문제를 찾아 해결할 수 있다.
JDBC는 자바 개발자라면 꼭 알아야하는 필수 기본 기술이다.
```

# 커넥션 풀 이해
__데이터베이스 커넥션을 매번 획득__
1. 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다.
2. DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다.
3. DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달한다.
4. DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다.
5. DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

```
이렇게 커넥션을 계속해서 새로 만들게 되면 리소스를 그만큼 사용하는 것이기 때문에 응답속도에 영향을 준다.
이런 문제를 해결하기 위한것이 바로 커넥션을 미리 생성해두고 사용하는것이며 
이것을 커넥션 풀 이라고 한다.
이 방법을 사용하면 커넥션을 맺는 시간이 사라진다.
참고로 이방법을 사용하면 커넥션을 끊는게 아니라 커넥션을 커넥션 풀에 반환을 해야한다.
대표적인 커넥션 풀 오픈소스는 commons-dbcp2, tomcat-jdbc pool, HikariCP 등이 있으며
이제는 대부분 hikariCP를 사용하며 스프링부트 2.0부터는 기본 커넥션 풀로 hikariCP를 제공한다.
```

# DataSource 이해
커넥션을 획득하는 방법은 크게 DBCP2, Hikari CP, DriverManager DataSource(스프링 제공)가 있다.
```
만약 DriverManager에서 Hikari CP로 변경을 한다면 사용법이 달라질 것이다.
이런 문제를 해결하기 위해 DataSource라는 인터페이스를 제공하며
DataSource는 커넥션을 획득하는 방법을 추상화하는 인터페이스다.
```

# 트랜잭션 - 개념 이해
`트랜잭션이란 하나의 거래를 안전하게 처리하도록 보장해주는 것을 뜻한다.`

## 트랜잭션 ACID
1. 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야한다. 
2. 일관성: 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
3. 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준을 선택할 수 있다.
4. 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야한다.

__트랜잭션 격리 수준 - Isolation level__
- READ UNCOMMITED(커밋되지 않은 읽기) : 성능은 제일 좋지만 데이터 보장이 안된다
- READ COMMITTED(커밋된 읽기) : 가장 많이 사용하는 트랜잭션 격리 수준이다.
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 가능)


## 트랜잭션 - 개념 이해
__트랜잭션 사용법__  
* 데이터 베이스에 결과를 반영하려면 commit을 하고  
   결과를 반영하지 않으려면 rollback을 호출하면 된다.
* 커밋을 호출하기 전까지는 임시로 데이터를 저장하며 
   해당 트랜잭션을 시작한 세션에서만 변경 데이터가 보이고 
   다른 세션에는 변경 데이터가 보이지 않는다.

```
커밋하지 않은 데이터를 다른곳에서 조회할 수 있으면 어떤 문제가 발생할까?
- 커밋하지 않는 데이터가 보인다면 데이터 정합성에 큰 문제가 발생하게된다.
- 커밋하지 않은 변경된 데이터가 보인다면 롤백이 되었을때 심각한 문제가 발생할 수 있다.
따라서 커밋 전의 데이터는 다른 세션에서 보이지 않는다. 

*주의* 트랜잭션 격리 수준을 READ UNCOMMITED를 하게되면 보이게 된다...
```

# DB 락 - 개념 이해
세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데   
세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.  
바로 트랜잭션의 원자성이 꺠지는 것이다.  
여기 더해 세션1이 중간에 롤백을 하게되면 세션2는 잘못된 데이터를 수정하는 문제가 발생한다.  
`이러한 문제를 해결하기 위해 데이터베이스는 락이라는 개념을 제공한다.`


## 세션2 락 타임아웃
`SET LOCK_TIMEOUT <milliseconds>` : 락 타임아웃 시간을 설정
세션1이 데이터를 변경하고 아직 커밋을 하지 않은 상태에서 세션2가 같은 데이터를 변경하려고 하면 설정한 시간만큼 대기해야한다.  
만약 세션1이 커밋이나 롤백을 하게되면 세션2는 락을 획득하게된다.  
또 설정한 시간까지 대기하게되면 락타임아웃 오류가 발생한다.
 

## DB 락 - 조회
*일반적인 조회는 락을 사용하지 않는다.*
* 데이터베이스마다 다르지만, 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 조회가 가능하다.

*조회와 락*
* 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 이럴 때는 `select for update` 구문을 사용하면 된다.

*조회 시점에 락이 필요한 경우는 언제일까?*
* 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.


## 트랜잭션 - 적용
- 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다. 
   비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 트랜잭션을 시작하려면 커넥션이 필요하다. 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 한다.
- 애플리케이션에서 DB 트랜잭션을 사용하려면 __트랜잭션을 사용하는 동안 같은 커넥션을 유지 해야한다.__ 그래야 같은 세션을 사용할 수 있다.
- 커넥션 유지가 필요한 메서드는 반드시 파라미터로 넘어온 커넥션을 사용해야 한다. 따라서 __커넥션을 새로 얻으면 안된다!__
   또한 __이후 서비스 로직이 끝날때 커넥션을 닫아야 한다.__


## 트랜잭션 동기화
스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 한다.
- 트랜잭션 추상화
- 리소스 동기화
```
__리소스 동기화__  
트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지해야한다.
결국 같은 커넥션을 동기화하기 위해서 이전에는 파라미터로 커넥션을 전달하는 방법을 사용했다.
파라미터로 커넥션을 전달하는 방법은 코드가 지저분해지는 것은 물론이고, 
커넥션을 넘기는 메서드와 넘기지 않는 메서드를 중복해서 만들어야 하는 등 여러가지 단점들이 많다. 
```

*커넥션과 세션*  
클라이언트는 커넥션으로 데이터베이스에 연결하고 데이터베이스 내부적으로 세션이 생성되어 명령을 실행할 수 있다.

*트랜잭션 매니저와 트랜잭션 동기화 매니저*  
- 스프링은 트랜잭션 동기화 매니저를 제공한다.
   이것은 쓰레드 로컬을 사용해서 커넥션을 동기화 해준다.
   트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용한다.
- 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 때문에 멀티쓰레드 상황에 안전하게 커넥션을 동기화 할 수 있다.
  따라서 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다.
  따라서 이전처럼 파라미터로 커넥션을 전달하지 않아도 된다.


## 트랜잭션 문제 해결 - 트랜잭션 매니저2
```
클라이언트의 요청으로 서비스 로직 실행
1. 서비스 계층에서 transactionManager.getTransaction()을 호출해서 트랜잭션을 시작
2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요.
   트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성한다.
3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.
4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.

6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드들을 호출한다. 이때 커넥션을 파라미터로 전달하지 않는다.
7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는 DataSourceUtils.getConnection()을 사용해서
   트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 이과정을 통해서 자연스럽게 같은 커넥션을 사용하고 트랜잭션도 유지된다.
8. 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.

9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다. 트랜잭션은 커밋하거나 롤백하면 종료된다.
10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
12. 전체 리소스를 정리한다.
   - 트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용후 꼭 정리해야 한다.
   - con.setAutoCommit(true)로 되돌린다. 커넥션 풀을 고려해야 한다.
   - con.close() 를 호출해서 커넥션을 종료한다. 커넥션 풀을 사용하는 경우 con.close() 를 호출하면 커넥션 풀에 반환된다.
```

## 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
- 반복적인 트랜잭션 로직을 해결하기 위해 트랜잭션 추상화, 트랜잭션 템플릿을 도입하였다.
- 반복코드는 해결할 수 있지만 순수 비즈니스 로직만 남기지는 못함.
- AOP를 통해 프록시를 도입하여 문제를 해결할 수 있음.


## 트랜잭션 문제 해결 - 트랜잭션 AOP 정리
```
1. 클라이언트가 요청을 한다.
2. 요청 로직에 @Transactional을 하였다면 AOP 프록시를 만든다.
3. AOP 프록시에서 트랜잭션 로직(시작, 커밋, 롤백, 자원 해제)을 실행하고 실제 서비스를 호출한다.
   3-1. 트랜잭션 시작시 스프링 컨테이너를 통해 빈으로 등록된 트랜잭션 매니저를 획득한다.
   3-2. 획득한 트랜잭션 매니저를 시작한다.
   3-3. 트랜잭션 매니저는 데이터 소스를 가지고 커넥션을 생성한다.
   3-4. 커넥션 auto commit을 false로 한다.
   3-5. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
   3-6. 보관된 커넥션을 가지고 비즈니스 로직에서 사용한 repository는 모두 트랜잭션 동기화 매니저에서 꺼내 쓴다.
   3-7. 비즈니스 로직이 끝났으면 리턴되어 성공이면 commit, 런타임 예외가 발생하면 rollback을 한다.
   3-8. 자원이 반환된다.
```

`선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리`
- 선언적 트랜잭션 관리
  - @Transactional 애노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용하는것
- 프로그래밍 방식의 트랜잭션 관리
  - `트랜잭션 매니저` 또는 `트랜잭션 템플릿` 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것을 프로그래밍 방식의 트랜잭션 관리라 한다.

## 스프링 부트의 자동 리소스 등록
```
스프링 부트를 사용하면 dataSource와 transactionManager는 자동으로 빈 등록을 해준다.
스프링 부트가 기본으로 생성하는 데이터소스는 커넥션풀을 제공하는 HikariDataSource이다.
스프링 부트가 어떤 트랜잭션 매니저를 빈으로 등록 할지는 현재 등록된 라이브러리를 보고 판단하며
JDBC를 사용하면 DataSourceTransactionManager를 빈으로 등록하고 JPA를 사용하면 JpaTransactionManager를 등록해준다.
```

## 트랜잭션 문제에 대한 최종 정리
### 애플리케이션 구조
- 프레젠테이션 계층
  - @Controller(UI 관련 처리)
- 서비스 계층
  - @Service (비즈니스 로직)
  - 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성하는게 좋다.
- 데이터 접근 계층
  - @Reoisutirt(DB 접근 처리)
  - 주사용 기술: JDBC, JPA, File, Redis, Mongo ...

```
MemberServiceV1은 특정 기술에 종속적이지 않고 순수한 비즈니스 로직만 존재한다.
V2에서는 트랜잭션을 적용하다 보니 JDBC 기술에 완전히 의존하게 되었다.
V3에서는 이를 해결하기 위해 트랜잭션을 추상화 하였고 
직접 커넥션을 받는 방법에서 DataSourceUtils를 이용하여 트랜잭션 동기화 매니저에 있는 커넥션을 받는방법을 이용하였다.

V3_1에서 같은 패턴이 반복되는 부분이 해결되지는 않았다.
예를 들어 try~catch, commit, rollback 같은 부분을 반복적으로 작성해야했다.
V3_2에서 이를 해결하기위해 TransactionTemplate을 이용하였고 commit, rollback과 같은 부분을 작성 하지 않을수 있게 되었다.
V3_3에서는 아직 해결하지 못한 try~catch 코드와 TransactionTemplate 실행 코드를 
@Transactional을 선언하여 프록시에서 대신 트랜잭션 코드를 실행하도록 하였고 서비스단에서는 순수 비즈니스 로직만 있도록 해결하였다.

스프링 부트를 사용하면 dataSource와 transactionManager는 자동으로 빈 등록을 해주어 코드 생략이 가능하다.
```

# 자바 예외 이해

## 예외 계층
스프링이 제공하는 예외 추상화를 이해하기 위해서는 먼저 자바 기본 예외에 대한 이해가 필요하다.  

```
Throwable은 최상위 예외이다 Throwable 위에 Object가있다.
그리고 Throwable 하위에는 Exception과 Error가 있으며
Error는 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외다.
이런 예외는 catch하면 안된다.
물론 최상위 예외인 Throwable도 catch 하면 안된다
Exception은 두가지로 나뉜다.
나뉘는 기준은 컴파일시점에서 예외를 체크하냐 안하냐이다.
체크 예외는 SqlException과 IOException 등 이 있으며
언체크 예외는 RuntimeException이며 하위에는 NPE와 IllegalArgumentException 등이 있다.
``` 

## 예외 기본 규칙
```
예외는 폭탄 돌리기와 같다. 잡아서 처리하거나, 처리할 수 없으면 밖으로 던져야 한다.
예외를 처리하고 나면 이후 로직은 정상 흐름으로 동작한다.
예외를 처리하지 않으면 호출한 곳으로 계속 던지게 된다.
```

### 예외에 대해서 2가지 기본 규칙을 기억하자!
- 예외는 잡아서 처리하거나 던져야 한다.
- 예외를 잡거나 던질때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.

### 예외를 처리하지 않고 계속 던지면 어떻게 될까?
- 자바의 main() 쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다.
- 웹 애플리케이션의 경우 여러사용자의 요청을 처리하기 때문에 하나의 예외 때문에 시스템이 종료되면 안된다.
    WAS가 해당 예외를 받아서 처리하는데 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.


## 언체크 예외 기본 이해
- RuntimeException과 그 하위 예외는 언체크 예외로 분류된다.
- 언체크 예외는 말 그대로 컴파일러가 예외를 체크하지 않는다는 뜻이다.
- 언체크 예외는 체크 예외와 기본적으로 동일, 차이는 throws를 선언하지 않고 생략할 수 있다. 이경우 자동으로 예외를 던진다.


    체크 예외 VS 언체크 예외
    체크 예외: 예외를 잡아서 처리하지 않으면 항상 throws 에 던지는 예외를 선언해야 한다.
    언체크 예외: 예외를 잡아서 처리하지 않아도 throws 를 생략 할 수 있다.

---

`공부 흐름 요약`
0. pure JDBC
   - 반복적인 커넥션 획득
   - 트랜잭션 처리 X
1. connection pool
   - DataSource를 이용한 커넥션 획득 
   - JdbcUtils를 이용한 자원 해제
   - 트랜잭션 처리 X
2. connection param
   - DataSource를 이용한 커넥션 획득
   - 자원 해제시 동일한 커넥션을 이용할 수 없으므로 동일한 커넥션을 파라미터로 받아서 가장 마지막에 실행되는 repository 함수에서 자원을 해제
   - 트랜잭션 처리 O
3. 트랜잭션 매니저를 이용한 동기화
   - 트랜잭션 동기화 매니저를 통해 동기화된 커넥션 획득
   - DataSourceUtils.getConnection() - 커넥션 동기화
   - DataSourceUtils.releaseConnection() - 동기화로 커밋 또는 롤백 후 자원해제
4. @Transactional을 이용한 트랜잭션 처리
   - 스프링 빈으로 등록이 되어있어야 처리가 된다. 
   - 코드가 매우 깔끔해진다
5. DataSource, TransactionManager bean 자동 등록